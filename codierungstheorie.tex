\documentclass{cheat-sheet}

\pdfinfo{
  /Title (Zusammenfassung Codierungstheorie)
  /Author (Tim Baumann)
}

\usepackage{nicefrac}
\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage[normalem]{ulem} % \sout

% Kleinere Klammern
\delimiterfactor=701

\newcommand{\F}{\mathbb{F}} % endlicher Körper
\newcommand{\GF}{\mathbb{GF}} % endlicher Körper
\renewcommand{\P}{\mathbb{P}} % Wahrscheinlichkeit
\newcommand{\CP}[2]{\P({#1}\mid{#2})} % Conditional Probability
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\newcommand{\err}{\text{err}} % Fehler
\newcommand{\ceil}[1]{\lceil #1 \rceil} % Aufrunden
\newcommand{\floor}[1]{\lfloor #1 \rfloor} % Abrunden
\DeclareMathOperator{\wt}{wt} % Hamming-Gewicht
\DeclareMathOperator{\spann}{span} % aufgespannte (lineare) Hülle
\newcommand{\lin}{\text{lin}} % linear
\newcommand{\scp}[2]{\left( #1 \!\mid\! #2 \right)} % Skalarprodukt
\newcommand{\homogen}{\text{hom}} % homogen
\newcommand{\divides}{|} % teilt
\DeclareMathOperator{\Ham}{Ham} % Hamming-Code (was sonst?)
\DeclareMathOperator{\Sim}{Sim} % Simplex-Code
\newcommand{\Proj}{\mathbb{P}} % Projektiver Raum
\newcommand{\Goley}{\mathcal{G}} % Goley-Code

\begin{document}

\maketitle{Zusammenfassung Codierungstheorie}

% Vorlesung vom 13. Oktober 2015

% 1. Grundproblemstellung
% §1.1 Aufgaben der Codierungstheorie

\[
  \text{Datenquelle} \enspace
  \xrightarrow{\text{senden}} \enspace
  \text{Kanal} \enspace
  \xrightarrow{\text{empfangen}} \enspace
  \text{Senke}
\]
Die Daten liegen bereits digitalisiert vor.
Mit dem Problem wie Daten wie bspw. natürliche Sprache möglichst effizient codiert werden, befasst sich die Informationstheorie.
In dieser Vorlesung soll es darum gehen, Daten mit einer Kanalcodierung so zu übersetzen, dass Fehler, die bei einer Übertragung über einen fehlerhaften Kanal, korrigiert oder zumindest bemerkt werden.

% (1.1) Bsp
% Nord = 00
% Ost = 01
% Süd = 10
% West = 11
%
% Nachrichtenmenge = Sendermenge = Empfängermenge

% §1.2 Einführende Beispiele

\begin{align*}
  \text{Datenquelle} \enspace
  & \xrightarrow[E]{\text{codieren}}
  \text{Code} \enspace
  \xrightarrow{\text{senden}} \enspace
  \text{Kanal} \enspace
  \xrightarrow{\text{empfangen}} \enspace
  \square \enspace \\
  & \xrightarrow[D]{\text{decodieren}} \enspace
  \text{Code}
  \xrightarrow[E^{-1}]{} \enspace
  \text{Senke}
\end{align*}

% (1.2) Bsp (Fortsetzung von (1.1))

% (1) Einführung eines Paritätsbit: $ab \mapsto c \coloneqq a+b (mod 2)$
% Nachrichtenmenge = {00,01,10,11}
% Sendermenge = {000,011,101,110}
% Empfängermenge = {000,001,010,011,100,101,110,111}

% 110 --> 010

% (2) Triple-Repetition

% Codieren

% 00 \mapsto 000000
% 01 \mapsto 010101
% 10 \mapsto 101010
% 11 \mapsto 111111

% decodieren mit dem Nächster-Nachbar-Prinzip
% Informationsrate 1/3

% (3) Optimaler Code zur 1-Fehlerkorrektur: Ein (5,4,3)-Code, binär

% 00 \mapsto 00000
% 01 \mapsto 01101
% 10 \mapsto 10110
% 11 \mapsto 11011

% 2^2 aus 2^5: Die Codes unterscheiden sich paarweise an mindestens 3 Positionen
% Informationsrate: 2/5

% 2. Formalisierung der Grundbegriffe

% §2.1 q-närer Code und Hamming-Abstand

\begin{defn}
  Ein \emph{Alphabet} ist eine Menge $Q$ mit $q > 1$ Elementen, typischerweise $\{ 0, 1, \ldots, q-1 \} \cong \Z_q$.
\end{defn}

\begin{bem}
  $\Z_q$ trägt die Struktur eines Ringes.
  Falls $q$ eine Primzahlpotenz ist, so gibt es einen Körper $\F_q$ mit $q$ Elementen.
\end{bem}

\begin{defn}
  Sei $n \geq 1$. Eine nichtleere Menge $C \subseteq Q^n$ mit $q = \abs{Q}$ heißt \emph{Blockcode} der Länge $n$ über $Q$ oder \emph{$q$-närer Code} der Länge $n$. Jedes $c = (c_1, \ldots, c_n) \in C$ heißt ein \emph{Codewort}.
  Falls $M = \abs{C}$, so nennt man $C$ einen \emph{$(n, M)$-Code} über $Q$.
\end{defn}

\begin{defn}
  Die \emph{Informationsrate} von $C$ ist dann $R(C) \coloneqq \log_n(M) / n$.
  Falls $\abs{M} = q^k$, dann ist $R(C) = k/n$.
\end{defn}

\begin{bem}
  Ist $Q \cong \F_q$, dann ist $Q^n$ ein $\F_q$-VR. Falls $C$ ein Unterraum von $Q^n$ ist, so ist $R(C) = \dim_{\F_q}(C) / n$.
\end{bem}

\begin{defn}
  Der \emph{Hamming-Abstand} von $u, v \in Q^n$ ist
  \[ d(u, v) \coloneqq \abs{\Set{i=1,\ldots,n}{u_i \neq v_i}}. \]
\end{defn}

\begin{lem}
  Der Hamming-Abstand ist eine Metrik auf $Q^n$.
\end{lem}

\begin{nota}
  Es sei $C \subseteq Q^n$ ein Code und $y \in Q^n$.
  Wenn $y$ empfangen wurde, so geht man davon aus, dass das gesendete Wort dasjenige des Codes mit den wenigsten Unterschieden zu $y$ ist, also ein Wort, welches den \emph{Hamming-Abstand} $d(y, C) \coloneqq \min_{c \in C} d(y, c)$ von $y$ zu $C$ realisiert.
  Es existiert i.\,A. kein eindeutiges solches Element, sondern eine Menge
  \[ N_c(y) \coloneqq \Set{\overline{c}}{d(y, C) = d(y, \overline{c})}. \]
\end{nota}

% §2.2 Das Decodierprinzip des nächsten Nachbarn

\begin{defn}
  \begin{itemize}
    \item Man nennt einen Kanal einen \emph{$q$-nären symmetrischen Kanal}, falls ein $p \in \R$ mit $0 < p < (q-1)/q$ existiert, sodass
    \[ \CP{\text{$\beta$ empfangen}}{\text{$\alpha$ gesendet}} = \nicefrac{p}{q-1} \]
    für alle $\beta \neq \alpha \in Q$, also $\CP{\text{$\alpha$ empfangen}}{\text{$\alpha$ gesendet}} = 1-p$.
    \item Man nennt einen Kanal \emph{gedächtnislos}, falls
    \[ \CP{\text{$y$ empfangen}}{\text{$c$ gesendet}} = \prod_{i=1}^n \CP{\text{$y_i$ empfangen}}{\text{$c_i$ gesendet}} \]
    für alle Wörter $x, y \in Q^n$ gilt.
  \end{itemize}
\end{defn}

\begin{defn}[\emph{Maximum-Likelihood-Prinzip}]
  Gegeben sei ein Code $C \subseteq Q^n$ und $y \in Q^n$.
  Gesucht ist $\hat{c} = \argmax_{c \in C} \CP{y}{c}$.
\end{defn}

\begin{satz}
  Es seien ein $q$-närer symm, gedächtnisloser Kanal und ein Code $C \subseteq Q^n$ gegeben.
  Sei $y \in Q^n$ und $\hat{c} \in C$.
  Dann sind äquivalent:
  \begin{itemize}
    \miniitem{0.48 \linewidth}{$\CP{y}{\hat{c}} = \max_{c \in C} \CP{y}{c}$}
    \miniitem{0.48 \linewidth}{$\hat{c} \in N_c(y)$}
  \end{itemize}
\end{satz}

% Vorlesung vom 15. Oktober 2015

\begin{defn}
  $D : Q^n \to C$ heißt \emph{vollständige Decodierabbildung}, falls
  \[ \fa{y \in Q^n} D(y) \in N_C(y). \]
\end{defn}

\iffalse
\begin{bem}
  Es gilt
  \[ \CP{y}{c} = \CP{c}{y} \cdot \tfrac{\P(y)}{\P(c)} = \CP{c}{y} \cdot \P(y) \cdot M \]
  Also: Ist $y$ gegeben, so wird $\CP{y}{c}$ genau dann maximal, wenn $\CP{c}{y}$ maximal ist.
\end{bem}
\fi

% §2.3 Shannons Hauptsatz der Kanalcodierung

\begin{defn}
  Die \emph{Kanalkapazität} eines $q$-nären symmetrischen Kanal ist
  \[ \kappa(q, p) \coloneqq \log_2(q) + p \cdot \log_2 (\nicefrac{p}{q-1}) + (1-p) \cdot \log_2 (1-p). \]
  Sie ist ein Maß für die maximale Information, die über den Kanal übertragen werden kann.
  Die \emph{Entropiefunktion} ist
  \[ H(q, p) \coloneqq 1 - \kappa(q, p). \]
\end{defn}

% q=2. \kappa(2,p) = 1 + p \log_2(p) + (1-p) \log_2(1-p)
% \kappa(2, \tfrac{1}{2}) = 1 + \tfrac{1}{2} \cdot (-1) + \tfrac{1}{2} \cdot (-1) = 0

% Ausgelassen: Skizze von \kappa(2, p)

\begin{defn}
  Sei $C$ ein Code und $D$ sei eine zugehörige (vollständige) Decodierabbildung.
  Die \emph{Restfehlerwahrscheinlichkeit} zu $(C, D)$:
  \[ \P_{\text{err}}(C) \coloneqq \max_{y \in Q^n, c \in C} \CP{D(y) \neq c}{\text{$c$ gesendet, $y$ empfangen}} \]
\end{defn}

% 2.9
\begin{satz}[\emph{Shannon}]
  Sei $0 < R < \kappa(q, p)$.
  Dann gibt es eine Folge $(C_n)_{n \in \N}$ von Codes und zugehörigen Decodierabbildungen $D_n$ mit: %folgenden Eigenschaften:
  \begin{itemize}
    \item $C_n$ ist ein $(n, M_n)$-Code mit Informationsrate $R \!\leq\! R(C_n) \!<\! \kappa(q, p)$
    \item $\lim_{n \to \infty} \left( \P_\err(C_n) \right) = 0$
  \end{itemize}
\end{satz}

% 3. Korrektureigenschaften und zwei Schranken

% §3.1 Fehlererkennung und -korrektur

% 3.1
\begin{defn}
  Der \emph{Minimalabstand} eines $(n, M)$-Codes $C$ über $Q$ ist
  \[ d \coloneqq d(C) \coloneqq \min_{c,c' \in C, c \neq c'} d(c,c'). \]
  Man sagt dann, $C$ ist ein $q$-närer $(n, M, d)$-Code.
\end{defn}

\begin{nota}
  Für $u \in Q^n$, $l \in \N$ sei $B_l(u) \coloneqq \Set{x \in Q^n}{d(x, x) \leq l}$.
\end{nota}

\begin{defn}
  \begin{itemize}
    \item Ein Code $C$ heißt \emph{$l$-fehlerkorrigierend}, falls $B_l(c) \cap B_{l'}(c') = \emptyset$ für alle $c, c' \in C$ mit $c \neq c'$.
    \item $C$ heißt \emph{$m$-fehlererkennend}, wenn $B_m(c) \cap C = \{ c \}$ f.\,a. $c \in C$.
    \item $C$ heißt \emph{genau $l$-fehlerkorrigierend/-erkennend}, falls $C$ $m$-fehlerkorr./-erkennend für $m \coloneqq l$ aber nicht $m \coloneqq l+1$ ist.
  \end{itemize}
\end{defn}

% 3.3
\begin{satz}
  Jeder $(n, M, d)$-Code $C$ ist genau
  \begin{itemize}
    \miniitem{0.48 \linewidth}{$(d{-}1)$-fehlererkennend und}
    \miniitem{0.49 \linewidth}{$(t \coloneqq \floor{\nicefrac{d-1}{2}})$-fehlerkorrigierend.}
  \end{itemize}
\end{satz}

\begin{bsp}
  $C = \{ 000, 111 \}$ ist ein binärer $(3, 2, 3)$-Code.
\end{bsp}

% Hauptproblemstellung
\begin{prob}
  Gegeben: $q$, Länge $n$, Minimalabstand $d$.
  Gesucht:
  \[ A_q(n, d) \coloneqq \max \Set{M}{\exists\,\text{$(n,M,d)$-Code}} \]
\end{prob}

\begin{defn}
  Ein $(n, M, d)$-Code heißt \emph{optimal}, falls $M = A_q(n, d)$.
\end{defn}

% §3.2 Singleton-Schranke

% 3.5
\begin{lem}
  Seien $q, n \in \N$, $q \geq 2$, $n \geq 1$.
  \begin{itemize}
    \item $A_q(n,1) = q^n$, realisiert durch $C = Q^n$.
    \item $A_q(n,n) = q$, realisiert durch $C = \Set{(a, \ldots, a)}{a \in Q} \subseteq Q^n$
    \item $d \leq d' \implies A_q(n, d) \geq A_q(n, d')$
    \item Sei $n \geq 2$ und $d \geq 2$. Dann gilt $A_q(n, d) \leq A_q(n-1,d-1)$.
  \end{itemize}
\end{lem}

% 3.6
\begin{kor}[\emph{Singletonschranke}]
  $A_q(n, d) \leq q^{n-d+1}$
\end{kor}

% 3.7
\begin{defn}
  Ein Code, der die Singletonschranke mit Gleichheit erfüllt, heißt ein \emph{MDS-Code} (MDS = maximum distance separable).
\end{defn}

\begin{bem}
  Sei $C \subseteq Q^n$ ein $(n, M, d)$-Code,
  $T = \{ 1 \!\leq t_1 < \ldots < t_{\abs{T}} \leq\! n \}$ und
  $\pi_T : C \to Q^{\abs{T}}, \enspace c \mapsto (c_{t_1}, \ldots, c_{t_{\abs{T}}})$.
  Ist $C$ ein MDS-Code, so ist $\pi_T$ bijektiv für alle $T$ mit $\abs{T} = n - d + 1$.
\end{bem}

\begin{satz}
  $A_q(n, 2) = q^{n-1}$, realisiert durch einen Code mit Prüfziffer
\end{satz}

% Vorlesung vom 20.10.2015
% §3.3

% 
\begin{defn}
  Sei $(G, +, 0)$ eine kommutative Gruppe. \\
  Das \emph{Hamming-Gewicht} von $x \in G^n$ ist
  \[
    \wt(x) \coloneqq \abs{\supp(x)},
    \quad \text{wobei} \quad
    \supp(x) \coloneqq \Set{i}{x_i \neq 0}.
  \]
\end{defn}

\begin{lem}
  Sei $G$ wie oben, $x, y \in G^n$.
  Dann $\wt(x-y) = d(x, y)$.
\end{lem}

\begin{satz}
  $A_q(n, 2) = q^{n-1}$ für alle $q \geq 2$ und alle $n \geq 2$.
\end{satz}

\begin{proof}
  Wir konstruieren einen $(n, q^{n-1}, 2)$-Code.
  Sei $R$ ein kommutativer Ring mit $q$ Elementen, $\lambda_1, \ldots, \lambda_{n-1} \in R$ Einheiten und $\lambda_n \coloneqq -1$. Wir betrachten die Kontrollgleichung
  \[
    \kappa : R^n \to R, \quad
    z \mapsto \lambda_1 z_1 + \ldots + \lambda_n z_n.
  \]
  Dann ist $C \coloneqq \ker(\kappa)$ ein 1-fehlererkennender Code.
\end{proof}

\begin{lem}
  Falls $\lambda_2 - \lambda_1, \ldots, \lambda_n - \lambda_{n-1}$ ebenfalls Einheiten sind, so sind Nachbarvertauschungen als Fehler erkennbar.
\end{lem}

\begin{bspe}
  \begin{itemize}
    \item Für $q=2, R=\Z_2, \lambda_1 = \ldots = \lambda_{n-1} = 1$ heißt $C \coloneqq \ker(\kappa)$ \emph{Parity-Check-Erweiterung}.
    \item Beim ISBN-Code ist $R \!=\! \Z_{11}$, $\lambda_1 \!=\! 1, \nldots, \lambda_9 \!=\! 9$, also $\kappa(z) = \sum_{i=1}^{10} i z_i$.
  \end{itemize}
\end{bspe}

\begin{bem}
  Es gilt $A_q(4,3) = q^2$ $\iff$ es gibt ein Paar orthogonaler lateinischer Quadrate der Größe $q$ $\iff$ $q \neq 2$ oder $q \neq 6$.
\end{bem}

% Betrachte nun q=2

\begin{lem}
  Für $x, y \in \Z_2^n$ gilt $d(x,y) = \wt(x) + \wt(y) - 2 \cdot \wt(x \cdot y)$.
\end{lem}

\begin{satz}
  Für alle $n \geq 1$ und $d$ ungerade gilt $A_2(n, d) = A_2(n+1,d+1)$, realisiert durch die Parity-Check-Erweiterung.
\end{satz}

\begin{defn}
  Zwei $(n,M)$-Codes $C$, $C'$ über $Q$ heißen \emph{äquivalent}, falls gilt:
  Es gibt eine Permutation $\gamma$ auf $\{ 1, \ldots, n \}$ und Permutationen $\sigma_1, \ldots, \sigma_n$ auf $Q$, sodass
  \[
    \alpha : Q^n \to Q^n, \quad
    (x_1, \ldots, x_n) \mapsto (\sigma_1(x_{\gamma(1)}), \ldots, \sigma_n(x_{\gamma(n)}))
  \]
  den Code $C$ auf $C'$ abbildet.
\end{defn}

% Ausgelassen: Beispiel

% Vorlesung vom 22.10.2015

% 3.16 Beispiel

\begin{bsp}
  $A_2(5, 3) = 4$ realisiert durch $\{ 00000, 11100, 00111, 11011 \}$
\end{bsp}

% §3.5 Kugelpackungsschranke

% Ausgelassen: Zeichnung

% 3.17
\begin{lem}
  Sei $Q$ ein Alphabet, $u \in Q^n$. %$B_l(u) \coloneqq \Set{x \in Q^n}{d(x,u) \leq l}$.
  Dann gilt
  \[ \abs{B_l(u)} = \sum_{j=0}^l {n \choose j} (\abs{Q}-1)^j. \]
\end{lem}

% 3.18
\begin{satz}[\emph{Kugelpackungsschranke} (KPS)]
  Sei $q \geq 2$, $n \geq 2$, $1 \leq d \leq n$, $t \coloneqq \floor{\tfrac{d-1}{2}}$. Dann ist
  \[ A_q(n, d) \leq q^n / \sum_{j=0}^t {n \choose j} (q-1)^j. \]
\end{satz}

\begin{defn}
  Ein $q$-närer $(n, M, d)$-Code $C$ heißt \emph{perfekt}, falls $M$ gleich der Kugelpackungsschranke ist.
\end{defn}

\iffalse
\begin{bsp}
  $n = 6$, $q = 2$, $d = 3$. \\
  Singleton-Schranke: $A_2(6, 3) \leq 2^{6-3+1} = 2^4 = 16$ \\
  Kugelpackungsschranke: $A_2(6, 3) \leq \floor{\frac{\floor{2^6}}{{6 \choose 0} (2-1)^0 + {6 \choose 1} (2-1)^1}} = 9$
\end{bsp}
\fi

\begin{bem}
  Die KPS kann zur \emph{Johnsen-Schranke} verbessert werden.
  Zusammen mit dem letzten Beispiel liefert diese $A_2(6, 3) = 8$.
\end{bem}

% 3.21
\begin{bsp}
  Für $q{=}2$, $n{=}7$, $d{=}3$ liefert die KGS genau $A_2(7,3) \leq 16$.
  % Später: Tatsächlich gilt $A_2(7,3) = 16$.
\end{bsp}

% §4. Grundlagen zu linearen Codes

% §4.1. Grundlagen zu endlichen Körpern

\begin{bem}
  Zu jeder Primzahlpotenz $q = p^m \geq 2$ gibt es bis auf Isomorphie genau einen Körper $\GF_q = \F_q$ mit $q$ Elementen. Die Charakteristik dieses Körpers ist $p$. Ist $q$ keine Primzahlpotenz, so gibt es auch keinen Körper mit $q$ Elementen.
\end{bem}

\begin{konstr}
  Sei $q = p^m$, $p$ prim. Dann gibt es ein irreduzibles Polynom $g(x)$ in $\Z_p$ mit $\deg(g) = m$.
  Dann ist $\F_q \coloneqq \Z_p[x]/(g(x))$.
\end{konstr}

% §4.2. Das Minimalgewicht eines linearen Codes

% $q \geq 2$ sei eine Primzahlpotenz

\begin{defn}
  Ein \emph{$\F_q$-linearer Code} der Länge $n$ ist ein $\F_q$-Teilraum $\F_q^n$.
\end{defn}

\begin{nota}
  Sei $C$ ein $\R_q$-linearer Code.
  Sei $k \coloneqq \dim(C)$.
  Dann ist $\abs{C} = q^k$, also $C$ ein $(n, q^k)$-Code.
  Man sagt, $C$ ist ein $[n, k]$-Code. \\
  Ist $d$ der Minimalabstand von $C$, so: $C$ ist ein $[n,k,d]$-Code.
\end{nota}

\begin{defn}
  Sei $C$ ein $\F_q$-linearer Code mit $\dim(C) \geq 1$.
  Das \emph{Minimalgewicht} von $C$ ist $\min \Set{\wt(c)}{c \in C, c \neq 0}$.
\end{defn}

% 4.4
\begin{lem}
  Sei $C$ ein $\F_q$-linearer Code mit $\dim(C) \geq 1$.
  Dann:
  \[ \text{Minimalgewicht von $C$ = Minimalabstand von $C$.} \]
\end{lem}

\begin{bsp}
  Folgender Code ist ein bin. $(6, 8, 3)$-Code bzw. $[6, 3, 3]$-Code:
  \[
    \arraycolsep=1pt
    \left\{ \begin{array}{rl}
      000000,
      100101,
      & 010110,
      001111, \\
      110011,
      101010,
      & 011001,
      111100
    \end{array} \right\} \!=\! \spann \{ 100101, 010110, 001111 \}
  \]
\end{bsp}

% §4.3 Hauptproblemstellung für lineare Codes

% Gegeben: $\F_q$, Länge $n$, Minimalabstand $d$
% Gewicht: $A_q^{\lin}(n, d) \leq $

\begin{prob}
  Gegeben sei $\F_q$, die Länge $n$ und der Minimalabstand $d$. \\
  Gesucht ist $A_q^\lin(n, d)$, die bestmögliche Anzahl Wörter eines Codes mit diesen Parametern.
\end{prob}

\begin{bem}
  Klar ist $A_q^\lin(n, d) \leq A_q(n, d)$.
\end{bem}

% 4.6
\begin{lem}
  \begin{itemize}
    \item $A_q^\lin(n, 1) = q^n = A_q(n, 1)$
    \item $A_q^\lin(n, n) = q = A_q(n, n)$
    \item $d \leq d' \implies A_q^\lin(n, d) \geq A_q^\lin(n, d')$
    \item Für $n \geq 2$, $d \geq 2$ ist $A_q^\lin(n, d) \leq A_q^\lin(n-1, d-1)$.
  \end{itemize}
\end{lem}

\begin{bem}
  Da die Parity-Check-Erweiterung durch eine lineare Abbildung geschieht, gilt:
\end{bem}

\begin{satz}
  $A_1^\lin(n, 2) = q^{n-1} = A_q(n,2)$
\end{satz}

\begin{satz}
  Falls $d$ ungerade, so ist $A_2^\lin(n, d) = A_2^\lin(n+1, d+1)$
\end{satz}

% Nordstrom-Robinson-Code:
% Ein (16, 256, 6)-Code über $\F_2$

% Vorlesung vom 27.10.2015

% §4.4 Die Generatormatrix

\begin{defn}
  Sei $C$ ein $[n,k]$-Code über $\F_q$, \dh{} es gibt eine injektive Codierabbildung $E : \F_q^k \to \F_q^n$ mit $\im(E) = C$.
  Dann heißt für jede Basis $g^1, \ldots, g^k \in C$ von $C$ die Matrix
  \[
    G \coloneqq \begin{psmallmatrix}
      g^1 \\ \vdots \\ g^k
    \end{psmallmatrix} \in \F_q^{k \times n} \qquad
    \text{eine \emph{Generatormatrix} von $C$.}
  \]
\end{defn}

\begin{bem}
  Dann ist $E(u) = uG = \sum_{j=1}^k u_j g^j \in C$
\end{bem}

% Ausgelassen: Bspe Parity-Check-Erweiterung und 5-Wiederholungscode

\begin{defn}
  Zwei $[n,k]$-Codes $C, C' \subseteq \F_q^n$ heißen \emph{linear äquivalent}, falls es~$\gamma \in S_n$ und $\lambda_1, \ldots, \lambda_n \in \F_q^{\times}$ gibt, sodass die monomiale Transf. \[ \alpha : \F_q^n \to \F_q^n, \enspace (x_1, \ldots, x_n) \mapsto (\lambda_1 x_{\gamma(1)}, \ldots, \lambda_n x_{\gamma(n)}) \]
  den Code $C$ in $C'$ überführt.
\end{defn}

\iffalse
\begin{bspe}
  binäre $[5, 2, 3]$-Codes
  
  $C_1$ hat Generatormatrix $G_1 = \begin{psmallmatrix}
    11100 \\
    00111
  \end{psmallmatrix}$,
  $C_1 = \{ 00000, 111100, 00111, 11011 \}$
  
  $C_2$ hat Generatormatrix $G_2 = \begin{psmallmatrix}
    011001 \\
    10110
  \end{psmallmatrix}$
  $C_2 = \{ 00000, 01101, 10110, 11011 \}$
\end{bspe}
\fi

\begin{defn}
  Ein $[n,k]$-Code heißt \emph{systematisch}, falls die ersten $k$ Spalten seiner Generatormatrix die Standardbasisvektoren sind.
\end{defn}

% §4.5 Gewichtsminimale Repäsentanten und Standard-Array-Decodierung

\begin{nota}
  Sei $C \subset \F_q^n$ ein UVR. Für $x, y \in \F_q^n$ schreiben wir
  \[ x \equiv y \pmod{C} \coloniff x-y \in C. \]
  Die zu $x \in V$ gehörende Kongruenzklasse modulo $C$ ist $x + C$.
\end{nota}

\begin{defn}
  Ein Repräsentantensystem $\mathcal{R}$ dieser Klassen heißt \emph{gewichtsminimal}, falls $\wt(r) = \min_{c \in C} \wt(r+c)$ für alle $r \in \mathcal{R}$.
\end{defn}

\begin{satz}
  Sei $C$ ein $[n, k]$-Code über $\F_q$, $\mathcal{R}$ ein gewichtsmin. Repräsen- tantensystem mod $C$.
  Zu $y \in \F_q^n$ sei $\mathcal{R}(y) \in \R$ mit $\mathcal{R}(y) + C = y + C$.
  Dann ist $D : \F_q^n \to C, \enspace y \mapsto y - \mathcal{R}(y)$ eine Decodierabbildung.
\end{satz}

% Ausgelassen: Beispiel

% TODO: Standard-Array-Decodierung beschreiben

% §4.6 Dualer Code: Kontrollmatrix und Syndromdecodierung

\begin{bem}
  Sei $\F$ ein Körper, $n \in \N^*$.
  Das Standard-Skalarprodukt
  \[
    \scp{\blank}{\blank} : \F^n \times \F^n \to \F,
    \enspace (x, y) \mapsto \sum_{i=1}^n x_i y_i
  \]
  ist eine nicht-ausgeartete, symmetrische Bilinearform.
\end{bem}

% Ausgelassen: Definition des Orthogonalraums

\begin{acht}
  Es ist $\dim(U^\perp) = n - k$, im Allgemeinen gilt aber $U \cap U^\perp \neq 0$, \zB{} ist $11011 \in \F_2^5$ senkrecht zu sich selbst.
\end{acht}

\begin{defn}
  Sei $C$ ein $[n,k]$-Code über $\F_q$.
  Dann heißt $C^\perp$ der zu $C$ gehörende \emph{duale Code}.
\end{defn}

\begin{defn}
  Die Generatormatrix $H$ von $C^\perp$ heißt \emph{Kontrollmatrix} zu $C$.
\end{defn}

\begin{lem}
  $x \in C \iff H x^T = 0$
\end{lem}

\begin{alg}
  Sei $C$ ein $[n,k]$-Code, $H \in \F_q^{n-k \times n}$ die Kontrollmatrix.
  Dann ist
  \[ \psi_H : \F_q^n \to \F_q^{n-k}, \enspace x \mapsto H x^T \]
  eine surjektive lineare Abbildung mit $\ker(\psi_H) = C$.
  \begin{itemize}
    \item Sei $c \in C$ gesendet, $y \in \F_q^n$ empfangen, etwa $y = c + e$.
    Wir als Empfänger kennen jedoch $c$ und $e$ nicht, nur $y$.
    Trotzdem können wir das \emph{Syndrom} $s \coloneqq \phi_H(y) = H c^T + H e^T = H e^T \in \F_q^{n-k}$ berechnen.
    \item Wahrscheinlich ist $e$ ein gewichtsminimaler Repräsentant von $y$.
    Sei also $\mathcal{R}$ ein minimales Repräsentantensystem. \\
    Dann ist $\psi \coloneqq \psi_H|_{\mathcal{R}} : \mathcal{R} \to \F_q^{n-k}$ bijektiv. \\
    Dann definiert $D(y) \coloneqq y - \psi^{-1}(s)$ eine Decodierabbildung.
  \end{itemize}
\end{alg}

% Vorlesung vom 29.10.2015

\begin{satz}
  Sei~$C$ ein linearer $[n, k, d]$-Code über $\F_q$, $H$~eine Kontroll- matrix zu~$C$.
  Dann gilt:
  \begin{align*}
    d &= 1 + \max \Set{a \in \N^*}{\text{je $a$ Spalten von $H$ sind lineare unabhängig}} \\
    &= \min \Set{m \in \N^*}{\text{es gibt $m$ linear abhängige Spalten in $H$}}
  \end{align*}
\end{satz}

\begin{defn}
  Sei~$C$ ein linearer Code der Länge~$n$ über $\F_q$. \\
  Die \emph{Gewichtsverteilung von~$C$} ist
  $A = A_C \in \N^{\{ 0, 1, \ldots, n \}}$ mit
  \[
    A(i) \coloneqq \Set{w \in C}{\wt(w) = i}, \quad
    0 \leq i \leq n.
  \]
\end{defn}

\begin{bem}
  Es gilt $A_0 = 1$ und $A_1 = A_2 = \ldots = A_{d-1} = 0$, falls~$d$ das Minimalgewicht von $C$ ist.
\end{bem}

\begin{defn}
  $A_C(Z) \coloneqq \sum_{i=0}^k A_i Z^k \in \C[Z]$ heißt \emph{Gewichtszählpolynom},
  \[ A_C^\homogen(X, Y) \coloneqq \sum_{i=0}^n A_i X^{n-i} \cdot Y^i \in \C[X, Y] \]
  heißt \emph{homogenes Gewichtszählpolynom}.
\end{defn}

\begin{bem}
  \inlineitem{$A_C(Z) = A_C^\homogen(1, Z)$} \quad
  \inlineitem{$A_C^\homogen(X, Y) = X^n \cdot A_C(\tfrac{Y}{X})$}
  \begin{itemize}
    \item Aus $A_C(X, Y)$ erhält man durch die sogenannte Mac-Williams-Transformation $A_{C^\perp}(X, Y)$
  \end{itemize}
\end{bem}

% §5. Hamming-Codes

% §5.1. Die Parameter eines 1-fehlerkorrigierenden perfekten linearen Codes

\begin{lem}
  Sei $C$ ein perfekter $(n, M, d)$-Code. %über $Q$ mit $q = \abs{Q}$.
  Dann ist $d$ ungerade.
\end{lem}

\begin{bem}
  Wir betrachten nun perfekte Codes $C$ mit $t=1$, also $d=3$.
  Es gilt dann $\abs{C} = \nicefrac{q^n}{1 + n(q-1)}$, es ist also $1+n(q-1)$ ein Teiler von~$q^n$.
  Beispielsweise ist für~$q \geq 2$ und~$n = q+1$ die Zahl $1 + n(q-1) = q^2$ ein Teiler von~$q^n$.
  Diese Teilbarkeit ist eine notwendige, aber nicht hinreichende Bedingung für die Existenz eines perfekten $(n, M, 3)$-Codes über $Q$ mit $q = \abs{Q}$.
  %Zum Bsp gibt es keinen perfekten Code bei $q=6$.
\end{bem}

\begin{lem}
  Seien $p, u, v \in \N$, $p \geq 2$. Dann gilt $u \divides v \iff p^u - 1 \divides p^v - 1$.
\end{lem}

\begin{prop}
  Sei $C$ perfekt mit $t=1$ über $Q$, wobei $\abs{Q} = q$ eine Primzahlpotenz ist.
  Dann ist $\abs{C}$ eine $q$-Potenz.
\end{prop}

\begin{bem}
  Sei nun $q \geq 2$ eine Primzahlpotenz, $C$ ein $q$-närer perfekter $(n, M, 3)$-Code.
  Dann ist
  \[ q^k = \abs{C} = M = \nicefrac{q^n}{1 + n(q-1)} \iff n = \nicefrac{(q^{n-k} - 1)}{q - 1} \]
  Wie viele Lösungspaare $(n, k)$ gibt es bei festem $q$?
  Wir setzen $m \coloneqq n - k$.
  Dann ist $k(m) \coloneqq n - m$ und $n(m) \coloneqq \tfrac{q^m - 1}{q - 1}$.
  Die Lösungspaare hängen damit nur noch vom Parameter $m$ ab.
\end{bem}

% Vorlesung vom 3.11.2015

% 5.5
\begin{satz}
  Zu jedem $m \geq 2$ und zu jeder Primzahlpotenz $q \geq 2$ gibt es einen linearen perfekten $[\tfrac{q^m - 1}{q - 1}, \tfrac{q^m - 1}{q - 1} - m, 3]$-Code über $\F_q$.
\end{satz}

% 5.6
\begin{kor}
  Ist $q \geq 2$ eine Primzahlpotenz, so gilt
  \[
    A^\lin_q \left( \tfrac{q^m - 1}{q - 1}, 3 \right) =
    A_q \left( \tfrac{q^m - 1}{q - 1}, 3 \right) =
    q^{q^0 + \ldots + q^{m-1} - m}
    \quad
    \forall m \geq 2, m \in \N
  \]
\end{kor}

% §5.2 Konstruktion und Decodierung der binären Hamming-Codes

% ausgelassen: Tabelle von binären Hamming-Codes

\begin{konstr}
  Ein bin. \emph{Hamming-Code} $\Ham_2(m)$ (ein $[n, n {-} m, 3]$- Code mit $n \coloneqq 2^m - 1$) ist geg. durch die Kontrollmatrix $H \in \F_2^{m \times n}$, welche jeden Vektor aus $\F_2^m \setminus \{ 0 \}$ in genau einer Spalte stehen hat.
\end{konstr}

\begin{alg}[Decodierung von binären Hamming-Codes]\mbox{}\\
  Angenommen, die Spalten der Kontrollmatrix $H$ codieren die Zahlen $1, \ldots, 2^m - 1$ im Binärsystem und sind geordnet.
  Sei $y \in \F_2^n$ empfangen worden.
  Falls $Hy = 0$, so wurde wsl. $y$ gesendet.
  Falls das Syndrom $Hy$ ungleich null ist, so ist vermutlich das $j$-te Bit gekippt, wobei $j$ die Zahl ist, deren Binärcodierung $Hy$ ist.
\end{alg}

% §5.3 Untersuchung des binären [7,4]-Hamming-Codes

% 5.2
\begin{prop}
  Sei $m \geq 2$, $n = 2^m - 1$ und $A \in \N^{0, 1, \ldots, \N}$ die Gewichtsverteilung des $[n, n - m, 3]$-Hamming-Codes.
  Dann gilt $A_{n-j} = A_j$ für alle $j = 0, 1, \ldots, 2^{m-1} - 1$.
\end{prop}

% 5.11
\begin{satz}
  Die Gewichtsverteilung des binären $[7,4]$-Hamming-Codes ist
  \[ A = (1, 0, 0, 7, 7, 0, 0, 1). \]
\end{satz}

\begin{bem}
  Sei $C = \Ham_2(3)$, $C_3 \coloneqq \Set{c \in C}{\wt(c) = 3}$.
  Für $c \in C_3$ seien $P(c) \coloneqq \Set{i = 1, \ldots, 7}{c_i = 1}$ die Positionen der in $c$ gesetzten Bits. \\
  Falls $i \in P(c)$, so sagen wir, dass $i$ auf der Geraden $c$ liege. \\
  Dies definiert die folgende geometrische Struktur:
\begin{center}
  % http://tex.stackexchange.com/a/208907
  \begin{tikzpicture}[scale=0.6]
    \draw (30:1)  -- (210:2)
          (150:1) -- (330:2)
          (270:1) -- (90:2)
          (90:2)  -- (210:2) -- (330:2) -- cycle
          (0:0)   circle (1);
    \fill (0:0)   circle(3pt)
          (30:1)  circle(3pt)
          (90:2)  circle(3pt)
          (150:1) circle(3pt)
          (210:2) circle(3pt)
          (270:1) circle(3pt)
          (330:2) circle(3pt);
    \node at (2,2) [right] {\sout{Die Heiligtümer des Todes}};
    \node at (2,1.25) [right] {\emph{Fano-Ebene}};
    \node at (2,0.5) [right] {$S_1(2,3,7)$-Blockplan};
    \node at (2,-0.25) [right] {Steinersystem};
    \node at (2,-1) [right] {Projektive Ebene $PG(2, \F_2)$};
  \end{tikzpicture}
\end{center}
  Wir bemerken, dass jede Gerade drei Punkte enthält, jeder Punkt auf drei Geraden liegt, durch je zwei verschiedene Punkte genau eine Gerade verläuft und jedes Paar von Geraden sich in genau einem Punkt schneidet.
  Die Vierecke in der Fano-Ebene sind die Komplemente von Geraden.
  Sie entsprechen den Codeworten mit Hamming-Gewicht 4.
  % ausgelassen: andere Möglichkeit, wie man aus $C$ die Fano-Ebene erhält
\end{bem}

% Vorlesung vom 5.11.2015

% 5.14
\begin{satz}
  Die Parity-Check-Erweiterung des $[7, 4]$-Hamming-Codes ist ein binärer $[8, 4, 4]$-Code.
  Dieser ist selbst-dual und optimal.
  Sein homogenes Gewichtszählpolynom ist $X^8 + 14 X^4 Y^4 + Y^8$.
\end{satz}

% §5.4 q-näre lineare Hamming-Codes

\begin{konstr}
  Wir definieren auf $A \coloneqq \F_q^n \setminus \{ 0 \}$ eine Äq'relation durch
  \[ u \sim v \coloniff \ex{\lambda \in \F_q} u = \lambda v. \]
  Wir setzen $\Proj \coloneqq PG(m-1, \F_q) \coloneqq A/{\sim}$.
  Es gilt $\abs{\Proj} = \nicefrac{q^m - 1}{q - 1} = n$. \\
  Sei $v_1, \ldots, v_n$ ein Representantensystem der Äquivalenzklassen. \\
  Dann definiert die Kontrollmatrix $H_q(m) \coloneqq (v_1 \cdots v_n)^T \in \F_q^{m \times n}$ den \emph{$q$-nären Hamming-Code} $\Ham_q(n)$.
\end{konstr}

\begin{bem}
  % Wir wählen das Representantensystem so, dass für alle $i = 1, \ldots, n$ gilt:
  % Sei $j$ minimal mit $(v_i)_j \neq 0$. Dann ist $v_i = 1$.
  Wir wählen das Representantensystem wie folgt:
  \[
    \left\{ \begin{psmallmatrix} 0 \\ \vdots \\ 0 \\ 0 \\ 1 \end{psmallmatrix} \right\} \cup
    \left\{ \begin{psmallmatrix} 0 \\ \vdots \\ 0 \\ 1 \\ * \end{psmallmatrix} \right\} \cup \ldots \cup
    \left\{ \begin{psmallmatrix} 1 \\ * \\ \vdots \\ * \\ * \end{psmallmatrix} \right\},
  \]
  also so, dass der erste Eintrag jedes Vektors eine 1 ist.
\end{bem}

% 5.16
\begin{alg}[Decodieren des $q$-nären Hamming-Codes]
  Sei $y$ empfangen mit höchstens einem Fehler.
  Berechne das Syndrom $s = H_q(m)y^T$.
  Falls $s = 0$, so ist $D(y) \coloneqq y$.
  Angenommen, $s_i \neq 0$.
  Sei $i$ minimal mit $s_i \neq 0$.
  Dann ist $\nicefrac{s}{s_i}$ eine Spalte von $H_q(m)$, etwa die $l$-te Spalte.
  Decodiere $D(y) \coloneqq y - s_i \cdot e_l$.
\end{alg}

% §5.5 Die Familie der Simplex-Codes

\begin{defn}
  Sei $q \geq 2$ eine Primzahlpotenz und $m \geq 2$.
  Der Code $\Sim_q(m) \coloneqq \Ham_q(m)^\perp$ heißt \emph{Simplex-Code}.
\end{defn}

\begin{bem}
  $\Sim_q(m)$ ist ein $[n, m]$-Code.
\end{bem}

\begin{satz}
  $\Sim_q(m)$ ist \emph{gewichtskonstant}, \dh{} jedes vom Nullwort verschiedene Codewort hat Gewicht $q^{m-1}$.
\end{satz}

\begin{bem}
  Also ist $A_{\Sim_q(m)}(z) = 1 + (q^m - 1) \cdot z^{q^{m-1}}$.
\end{bem}

% §5.6 Gewichtsverteilung der binären Hamming-Codes

\begin{satz}
  $A_{\Ham_2(m)}(z) = \tfrac{1}{n+1} (1+z)^n + \tfrac{n}{n+1} (1+z)^{\tfrac{n-1}{2}} \cdot (1-z)^{\tfrac{n+1}{2}}$,
  wobei $n = 2^m - 1$.
  Es gilt die Rekursionsgleichung
  \[ {n \choose l-1} = (n-l+2) \cdot A_{l-2} + A_{l-1} + l \cdot A_l. \]
\end{satz}

% Vorlesung vom 10.11.2015

% §6. Die Golay-Codes und deren Erweiterungen

\begin{prop}
  Ist $n \geq 3$ ungerade, so ist der binäre $n$-Wiederholungscode ein perfekter Code.
\end{prop}

\begin{bem}
  Es sei $d \geq 5$, $q$ eine Primzahlpotenz.
  Für $n \leq 1000$, $\log_q(M) \leq 1000$ und $q \leq 1000$ könnte es nur Codes mit folgenden Parametern geben:
  \begin{itemize}
    \item $q=2$, $n=23$, $d=7$, $M=2^{12} = 4096$ % \Goley(24)
    \item $q=2$, $n=90$, $d=5$, $M=2^{78}$
    \item $q=3$, $n=11$, $d=5$, $M=3^6=729$ % \Goley(12)
  \end{itemize}
\end{bem}

\begin{satz}
  Es gibt keinen binären $(90, 2^{78}, 5)$-Code.
\end{satz}

\begin{bem}
  Sei $q$ eine Primzahlpotenz, $C$ ein perfekter $q$-närer $(n, M, 2t+1)$-Code.
  Dann hat das \emph{Lloyd-Polynom}
  \[ L_t(X) \coloneqq \sum_{j=0}^t (-1)^j \cdot (q-1)^{t-j} \cdot {X-1 \choose j} {n-1-X \choose t-j} \]
  mindestens $t$ verschiedene Nullstellen in $\{ 1, \ldots, n \}$.
\end{bem}

\begin{bsp}
  Für $n=90$, $q=2$, $t=2$ ist $L_2(X) = 2 (X^2 - 90 + 2003)$.
  Dessen Diskriminante ist $88$, also keine Quadratzahl.
  Somit besitzt $L_2(X)$ keine natürlichen Nullstellen.
\end{bsp}

\begin{prop}
  Sei $C$ ein binärer selbst-dualer Code (insb. linear).
  Dann gilt:
  \begin{itemize}
    \item Jedes Codewort hat ein gerades Gewicht.
    \item $\fa{c \in C} 4 \divides \wt(c) \iff$ $C$ hat eine Basis $B$ mit $\fa{b \in B} 4 \divides \wt(c)$
  \end{itemize}
\end{prop}

\begin{prop}
  Für jeden ternären selbstdualen Code $C$ gilt $\fa{c \!\in\! C\!}\! 3 \divides \wt(c)$.
\end{prop}

\begin{konstr}
  Beginne mit dem $[7, 4, 3]$-Hamming-Code $C_1$ mit Generatormatrix
  \[
    G_1 = \begin{pmatrix}
      1 & 1 & 0 & 1 & 0 & 0 & 0 \\
      0 & 1 & 1 & 0 & 1 & 0 & 0 \\
      0 & 0 & 1 & 1 & 0 & 1 & 0 \\
      0 & 0 & 0 & 1 & 1 & 0 & 1
    \end{pmatrix}
  \]
  Sei $\overline{C}_1$ die Parity-Check-Erweiterung von $C_1$ mit Generatormatrix
  \[
    \overline{G}_1 = \begin{pmatrix}
      & 1 \\
      G_1 & 1 \\
      & 1 \\
      & 1
    \end{pmatrix}
  \]
  Dann ist $\overline{C}_1$ eine selbstdualer $[8,4,4]$-Code über $\F_2$.
  
  Sei $G_2$ die Matrix $G_1$ mit Spalten in umgekehrter Reihenfolge,
  \[
    G_2 = \begin{pmatrix}
      0 & 0 & 0 & 1 & 0 & 1 & 1 \\
      0 & 0 & 1 & 0 & 1 & 1 & 0 \\
      0 & 1 & 0 & 1 & 1 & 0 & 0 \\
      1 & 0 & 1 & 1 & 0 & 0 & 0
    \end{pmatrix}
  \]
  der Code $C_2$ von $G_2$ erzeugt, $\overline{C}_2$ die Parity-Check-Erw. von $C_2$.
  Dann ist $\overline{C}_2$ selbstdual.
\end{konstr}

\begin{satz}
  Sei $\Gamma \subset \F_2^{24}$ definiert durch
  \[ \Gamma \coloneqq \Set{(a+f, b+f, a+b+f)}{a, b \in \overline{C}_1, f \in \overline{C}_2} \]
  Dann ist $\Gamma$ ein selbst-dualer binärer $[24, 12, 8]$-Code.
\end{satz}

\begin{defn}
  $\Gamma$ wird \emph{erweiterter binärer Goley-Code} $\Goley(24)$ genannt.
\end{defn}

\end{document}