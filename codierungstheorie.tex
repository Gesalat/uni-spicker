\documentclass{cheat-sheet}

\pdfinfo{
  /Title (Zusammenfassung Codierungstheorie)
  /Author (Tim Baumann)
}

\usepackage{nicefrac}

% Kleinere Klammern
\delimiterfactor=701

\newcommand{\F}{\mathbb{F}} % endlicher Körper
\newcommand{\GF}{\mathbb{GF}} % endlicher Körper
\renewcommand{\P}{\mathbb{P}} % Wahrscheinlichkeit
\newcommand{\CP}[2]{\P({#1}\mid{#2})} % Conditional Probability
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\newcommand{\err}{\text{err}} % Fehler
\newcommand{\ceil}[1]{\lceil #1 \rceil} % Aufrunden
\newcommand{\floor}[1]{\lfloor #1 \rfloor} % Abrunden
\DeclareMathOperator{\wt}{wt} % Hamming-Gewicht
\DeclareMathOperator{\spann}{span} % aufgespannte (lineare) Hülle
\newcommand{\lin}{\text{lin}} % linear
\newcommand{\scp}[2]{\left( #1 \!\mid\! #2 \right)} % Skalarprodukt
\newcommand{\homogen}{\text{hom}} % homogen
\newcommand{\divides}{|} % teilt

\begin{document}

\maketitle{Zusammenfassung Codierungstheorie}

% Vorlesung vom 13. Oktober 2015

% 1. Grundproblemstellung
% §1.1 Aufgaben der Codierungstheorie

\[
  \text{Datenquelle} \enspace
  \xrightarrow{\text{senden}} \enspace
  \text{Kanal} \enspace
  \xrightarrow{\text{empfangen}} \enspace
  \text{Senke}
\]
Die Daten liegen bereits digitalisiert vor.
Mit dem Problem wie Daten wie bspw. natürliche Sprache möglichst effizient codiert werden, befasst sich die Informationstheorie.
In dieser Vorlesung soll es darum gehen, Daten mit einer Kanalcodierung so zu übersetzen, dass Fehler, die bei einer Übertragung über einen fehlerhaften Kanal, korrigiert oder zumindest bemerkt werden.

% (1.1) Bsp
% Nord = 00
% Ost = 01
% Süd = 10
% West = 11
%
% Nachrichtenmenge = Sendermenge = Empfängermenge

% §1.2 Einführende Beispiele

\begin{align*}
  \text{Datenquelle} \enspace
  & \xrightarrow[E]{\text{codieren}}
  \text{Code} \enspace
  \xrightarrow{\text{senden}} \enspace
  \text{Kanal} \enspace
  \xrightarrow{\text{empfangen}} \enspace
  \square \enspace \\
  & \xrightarrow[D]{\text{decodieren}} \enspace
  \text{Code}
  \xrightarrow[E^{-1}]{} \enspace
  \text{Senke}
\end{align*}

% (1.2) Bsp (Fortsetzung von (1.1))

% (1) Einführung eines Paritätsbit: $ab \mapsto c \coloneqq a+b (mod 2)$
% Nachrichtenmenge = {00,01,10,11}
% Sendermenge = {000,011,101,110}
% Empfängermenge = {000,001,010,011,100,101,110,111}

% 110 --> 010

% (2) Triple-Repetition

% Codieren

% 00 \mapsto 000000
% 01 \mapsto 010101
% 10 \mapsto 101010
% 11 \mapsto 111111

% decodieren mit dem Nächster-Nachbar-Prinzip
% Informationsrate 1/3

% (3) Optimaler Code zur 1-Fehlerkorrektur: Ein (5,4,3)-Code, binär

% 00 \mapsto 00000
% 01 \mapsto 01101
% 10 \mapsto 10110
% 11 \mapsto 11011

% 2^2 aus 2^5: Die Codes unterscheiden sich paarweise an mindestens 3 Positionen
% Informationsrate: 2/5

% 2. Formalisierung der Grundbegriffe

% §2.1 q-närer Code und Hamming-Abstand

\begin{defn}
  Ein \emph{Alphabet} ist eine Menge $Q$ mit $q > 1$ Elementen, typischerweise $\{ 0, 1, \ldots, q-1 \} \cong \Z_q$.
\end{defn}

\begin{bem}
  $\Z_q$ trägt die Struktur eines Ringes.
  Falls $q$ eine Primzahlpotenz ist, so gibt es einen Körper $\F_q$ mit $q$ Elementen.
\end{bem}

\begin{defn}
  Sei $n \geq 1$. Eine nichtleere Menge $C \subseteq Q^n$ mit $q = \abs{Q}$ heißt \emph{Blockcode} der Länge $n$ über $Q$ oder \emph{$q$-närer Code} der Länge $n$. Jedes $c = (c_1, \ldots, c_n) \in C$ heißt ein \emph{Codewort}.
  Falls $M = \abs{C}$, so nennt man $C$ einen \emph{$(n, M)$-Code} über $Q$.
\end{defn}

\begin{defn}
  Die \emph{Informationsrate} von $C$ ist dann $R(C) \coloneqq \log_n(M) / n$.
  Falls $\abs{M} = q^k$, dann ist $R(C) = k/n$.
\end{defn}

\begin{bem}
  Ist $Q \cong \F_q$, dann ist $Q^n$ ein $\F_q$-VR. Falls $C$ ein Unterraum von $Q^n$ ist, so ist $R(C) = \dim_{\F_q}(C) / n$.
\end{bem}

\begin{defn}
  Der \emph{Hamming-Abstand} von $u, v \in Q^n$ ist
  \[ d(u, v) \coloneqq \abs{\Set{i=1,\ldots,n}{u_i \neq v_i}}. \]
\end{defn}

\begin{lem}
  Der Hamming-Abstand ist eine Metrik auf $Q^n$.
\end{lem}

\begin{nota}
  Es sei $C \subseteq Q^n$ ein Code und $y \in Q^n$.
  Wenn $y$ empfangen wurde, so geht man davon aus, dass das gesendete Wort dasjenige des Codes mit den wenigsten Unterschieden zu $y$ ist, also ein Wort, welches den \emph{Hamming-Abstand} $d(y, C) \coloneqq \min_{c \in C} d(y, c)$ von $y$ zu $C$ realisiert.
  Es existiert i.\,A. kein eindeutiges solches Element, sondern eine Menge
  \[ N_c(y) \coloneqq \Set{\overline{c}}{d(y, C) = d(y, \overline{c})}. \]
\end{nota}

% §2.2 Das Decodierprinzip des nächsten Nachbarn

\begin{defn}
  \begin{itemize}
    \item Man nennt einen Kanal einen \emph{$q$-nären symmetrischen Kanal}, falls ein $p \in \R$ mit $0 < p < (q-1)/q$ existiert, sodass
    \[ \CP{\text{$\beta$ empfangen}}{\text{$\alpha$ gesendet}} = \nicefrac{p}{q-1} \]
    für alle $\beta \neq \alpha \in Q$, also $\CP{\text{$\alpha$ empfangen}}{\text{$\alpha$ gesendet}} = 1-p$.
    \item Man nennt einen Kanal \emph{gedächtnislos}, falls
    \[ \CP{\text{$y$ empfangen}}{\text{$c$ gesendet}} = \prod_{i=1}^n \CP{\text{$y_i$ empfangen}}{\text{$c_i$ gesendet}} \]
    für alle Wörter $x, y \in Q^n$ gilt.
  \end{itemize}
\end{defn}

\begin{defn}[\emph{Maximum-Likelihood-Prinzip}]
  Gegeben sei ein Code $C \subseteq Q^n$ und $y \in Q^n$.
  Gesucht ist $\hat{c} = \argmax_{c \in C} \CP{y}{c}$.
\end{defn}

\begin{satz}
  Es seien ein $q$-närer symm, gedächtnisloser Kanal und ein Code $C \subseteq Q^n$ gegeben.
  Sei $y \in Q^n$ und $\hat{c} \in C$.
  Dann sind äquivalent:
  \begin{itemize}
    \miniitem{0.48 \linewidth}{$\CP{y}{\hat{c}} = \max_{c \in C} \CP{y}{c}$}
    \miniitem{0.48 \linewidth}{$\hat{c} \in N_c(y)$}
  \end{itemize}
\end{satz}

% Vorlesung vom 15. Oktober 2015

\begin{defn}
  $D : Q^n \to C$ heißt \emph{vollständige Decodierabbildung}, falls
  \[ \fa{y \in Q^n} D(y) \in N_C(y). \]
\end{defn}

\iffalse
\begin{bem}
  Es gilt
  \[ \CP{y}{c} = \CP{c}{y} \cdot \tfrac{\P(y)}{\P(c)} = \CP{c}{y} \cdot \P(y) \cdot M \]
  Also: Ist $y$ gegeben, so wird $\CP{y}{c}$ genau dann maximal, wenn $\CP{c}{y}$ maximal ist.
\end{bem}
\fi

% §2.3 Shannons Hauptsatz der Kanalcodierung

\begin{defn}
  Die \emph{Kanalkapazität} eines $q$-nären symmetrischen Kanal ist
  \[ \kappa(q, p) \coloneqq \log_2(q) + p \cdot \log_2 (\nicefrac{p}{q-1}) + (1-p) \cdot \log_2 (1-p). \]
  Sie ist ein Maß für die maximale Information, die über den Kanal übertragen werden kann.
  Die \emph{Entropiefunktion} ist
  \[ H(q, p) \coloneqq 1 - \kappa(q, p). \]
\end{defn}

% q=2. \kappa(2,p) = 1 + p \log_2(p) + (1-p) \log_2(1-p)
% \kappa(2, \tfrac{1}{2}) = 1 + \tfrac{1}{2} \cdot (-1) + \tfrac{1}{2} \cdot (-1) = 0

% Ausgelassen: Skizze von \kappa(2, p)

\begin{defn}
  Sei $C$ ein Code und $D$ sei eine zugehörige (vollständige) Decodierabbildung.
  Die \emph{Restfehlerwahrscheinlichkeit} zu $(C, D)$:
  \[ \P_{\text{err}}(C) \coloneqq \max_{y \in Q^n, c \in C} \CP{D(y) \neq c}{\text{$c$ gesendet, $y$ empfangen}} \]
\end{defn}

% 2.9
\begin{satz}[\emph{Shannon}]
  Sei $0 < R < \kappa(q, p)$.
  Dann gibt es eine Folge $(C_n)_{n \in \N}$ von Codes und zugehörigen Decodierabbildungen $D_n$ mit: %folgenden Eigenschaften:
  \begin{itemize}
    \item $C_n$ ist ein $(n, M_n)$-Code mit Informationsrate $R \!\leq\! R(C_n) \!<\! \kappa(q, p)$
    \item $\lim_{n \to \infty} \left( \P_\err(C_n) \right) = 0$
  \end{itemize}
\end{satz}

% 3. Korrektureigenschaften und zwei Schranken

% §3.1 Fehlererkennung und -korrektur

% 3.1
\begin{defn}
  Der \emph{Minimalabstand} eines $(n, M)$-Codes $C$ über $Q$ ist
  \[ d \coloneqq d(C) \coloneqq \min_{c,c' \in C, c \neq c'} d(c,c'). \]
  Man sagt dann, $C$ ist ein $q$-närer $(n, M, d)$-Code.
\end{defn}

\begin{nota}
  Für $u \in Q^n$, $l \in \N$ sei $B_l(u) \coloneqq \Set{x \in Q^n}{d(x, x) \leq l}$.
\end{nota}

\begin{defn}
  \begin{itemize}
    \item Ein Code $C$ heißt \emph{$l$-fehlerkorrigierend}, falls $B_l(c) \cap B_{l'}(c') = \emptyset$ für alle $c, c' \in C$ mit $c \neq c'$.
    \item $C$ heißt \emph{$m$-fehlererkennend}, wenn $B_m(c) \cap C = \{ c \}$ f.\,a. $c \in C$.
    \item $C$ heißt \emph{genau $l$-fehlerkorrigierend/-erkennend}, falls $C$ $m$-fehlerkorr./-erkennend für $m \coloneqq l$ aber nicht $m \coloneqq l+1$ ist.
  \end{itemize}
\end{defn}

% 3.3
\begin{satz}
  Jeder $(n, M, d)$-Code $C$ ist genau
  \begin{itemize}
    \miniitem{0.48 \linewidth}{$(d{-}1)$-fehlererkennend und}
    \miniitem{0.49 \linewidth}{$(t \coloneqq \floor{\nicefrac{d-1}{2}})$-fehlerkorrigierend.}
  \end{itemize}
\end{satz}

\begin{bsp}
  $C = \{ 000, 111 \}$ ist ein binärer $(3, 2, 3)$-Code.
\end{bsp}

% Hauptproblemstellung
\begin{prob}
  Gegeben: $q$, Länge $n$, Minimalabstand $d$.
  Gesucht:
  \[ A_q(n, d) \coloneqq \max \Set{M}{\exists\,\text{$(n,M,d)$-Code}} \]
\end{prob}

\begin{defn}
  Ein $(n, M, d)$-Code heißt \emph{optimal}, falls $M = A_q(n, d)$.
\end{defn}

% §3.2 Singleton-Schranke

% 3.5
\begin{lem}
  Seien $q, n \in \N$, $q \geq 2$, $n \geq 1$.
  \begin{itemize}
    \item $A_q(n,1) = q^n$, realisiert durch $C = Q^n$.
    \item $A_q(n,n) = q$, realisiert durch $C = \Set{(a, \ldots, a)}{a \in Q} \subseteq Q^n$
    \item $d \leq d' \implies A_q(n, d) \geq A_q(n, d')$
    \item Sei $n \geq 2$ und $d \geq 2$. Dann gilt $A_q(n, d) \leq A_q(n-1,d-1)$.
  \end{itemize}
\end{lem}

% 3.6
\begin{kor}[\emph{Singletonschranke}]
  $A_q(n, d) \leq q^{n-d+1}$
\end{kor}

% 3.7
\begin{defn}
  Ein Code, der die Singletonschranke mit Gleichheit erfüllt, heißt ein \emph{MDS-Code} (MDS = maximum distance separable).
\end{defn}

\begin{bem}
  Sei $C \subseteq Q^n$ ein $(n, M, d)$-Code,
  $T = \{ 1 \!\leq t_1 < \ldots < t_{\abs{T}} \leq\! n \}$ und
  $\pi_T : C \to Q^{\abs{T}}, \enspace c \mapsto (c_{t_1}, \ldots, c_{t_{\abs{T}}})$.
  Ist $C$ ein MDS-Code, so ist $\pi_T$ bijektiv für alle $T$ mit $\abs{T} = n - d + 1$.
\end{bem}

\begin{satz}
  $A_q(n, 2) = q^{n-1}$, realisiert durch einen Code mit Prüfziffer
\end{satz}

% Vorlesung vom 20.10.2015
% §3.3

% 
\begin{defn}
  Sei $(G, +, 0)$ eine kommutative Gruppe. \\
  Das \emph{Hamming-Gewicht} von $x \in G^n$ ist
  \[
    \wt(x) \coloneqq \abs{\supp(x)},
    \quad \text{wobei} \quad
    \supp(x) \coloneqq \Set{i}{x_i \neq 0}.
  \]
\end{defn}

\begin{lem}
  Sei $G$ wie oben, $x, y \in G^n$.
  Dann $\wt(x-y) = d(x, y)$.
\end{lem}

\begin{satz}
  $A_q(n, 2) = q^{n-1}$ für alle $q \geq 2$ und alle $n \geq 2$.
\end{satz}

\begin{proof}
  Wir konstruieren einen $(n, q^{n-1}, 2)$-Code.
  Sei $R$ ein kommutativer Ring mit $q$ Elementen, $\lambda_1, \ldots, \lambda_{n-1} \in R$ Einheiten und $\lambda_n \coloneqq -1$. Wir betrachten die Kontrollgleichung
  \[
    \kappa : R^n \to R, \quad
    z \mapsto \lambda_1 z_1 + \ldots + \lambda_n z_n.
  \]
  Dann ist $C \coloneqq \ker(\kappa)$ ein 1-fehlererkennender Code.
\end{proof}

\begin{lem}
  Falls $\lambda_2 - \lambda_1, \ldots, \lambda_n - \lambda_{n-1}$ ebenfalls Einheiten sind, so sind Nachbarvertauschungen als Fehler erkennbar.
\end{lem}

\begin{bspe}
  \begin{itemize}
    \item Für $q=2, R=\Z_2, \lambda_1 = \ldots = \lambda_{n-1} = 1$ heißt $C \coloneqq \ker(\kappa)$ \emph{Parity-Check-Erweiterung}.
    \item Beim ISBN-Code ist $R \!=\! \Z_{11}$, $\lambda_1 \!=\! 1, \nldots, \lambda_9 \!=\! 9$, also $\kappa(z) = \sum_{i=1}^{10} i z_i$.
  \end{itemize}
\end{bspe}

\begin{bem}
  Es gilt $A_q(4,3) = q^2$ $\iff$ es gibt ein Paar orthogonaler lateinischer Quadrate der Größe $q$ $\iff$ $q \neq 2$ oder $q \neq 6$.
\end{bem}

% Betrachte nun q=2

\begin{lem}
  Für $x, y \in \Z_2^n$ gilt $d(x,y) = \wt(x) + \wt(y) - 2 \cdot \wt(x \cdot y)$.
\end{lem}

\begin{satz}
  Für alle $n \geq 1$ und $d$ ungerade gilt $A_2(n, d) = A_2(n+1,d+1)$, realisiert durch die Parity-Check-Erweiterung.
\end{satz}

\begin{defn}
  Zwei $(n,M)$-Codes $C$, $C'$ über $Q$ heißen \emph{äquivalent}, falls gilt:
  Es gibt eine Permutation $\gamma$ auf $\{ 1, \ldots, n \}$ und Permutationen $\sigma_1, \ldots, \sigma_n$ auf $Q$, sodass
  \[
    \alpha : Q^n \to Q^n, \quad
    (x_1, \ldots, x_n) \mapsto (\sigma_1(x_{\gamma(1)}), \ldots, \sigma_n(x_{\gamma(n)}))
  \]
  den Code $C$ auf $C'$ abbildet.
\end{defn}

% Ausgelassen: Beispiel

% Vorlesung vom 22.10.2015

% 3.16 Beispiel

\begin{bsp}
  $A_2(5, 3) = 4$ realisiert durch $\{ 00000, 11100, 00111, 11011 \}$
\end{bsp}

% §3.5 Kugelpackungsschranke

% Ausgelassen: Zeichnung

% 3.17
\begin{lem}
  Sei $Q$ ein Alphabet, $u \in Q^n$. %$B_l(u) \coloneqq \Set{x \in Q^n}{d(x,u) \leq l}$.
  Dann gilt
  \[ \abs{B_l(u)} = \sum_{j=0}^l {n \choose j} (\abs{Q}-1)^j. \]
\end{lem}

% 3.18
\begin{satz}[\emph{Kugelpackungsschranke} (KPS)]
  Sei $q \geq 2$, $n \geq 2$, $1 \leq d \leq n$, $t \coloneqq \floor{\tfrac{d-1}{2}}$. Dann ist
  \[ A_q(n, d) \leq q^n / \sum_{j=0}^t {n \choose j} (q-1)^j. \]
\end{satz}

\begin{defn}
  Ein $q$-närer $(n, M, d)$-Code $C$ heißt \emph{perfekt}, falls $M$ gleich der Kugelpackungsschranke ist.
\end{defn}

\iffalse
\begin{bsp}
  $n = 6$, $q = 2$, $d = 3$. \\
  Singleton-Schranke: $A_2(6, 3) \leq 2^{6-3+1} = 2^4 = 16$ \\
  Kugelpackungsschranke: $A_2(6, 3) \leq \floor{\frac{\floor{2^6}}{{6 \choose 0} (2-1)^0 + {6 \choose 1} (2-1)^1}} = 9$
\end{bsp}
\fi

\begin{bem}
  Die KPS kann zur \emph{Johnsen-Schranke} verbessert werden.
  Zusammen mit dem letzten Beispiel liefert diese $A_2(6, 3) = 8$.
\end{bem}

% 3.21
\begin{bsp}
  Für $q{=}2$, $n{=}7$, $d{=}3$ liefert die KGS genau $A_2(7,3) \leq 16$.
  % Später: Tatsächlich gilt $A_2(7,3) = 16$.
\end{bsp}

% §4. Grundlagen zu linearen Codes

% §4.1. Grundlagen zu endlichen Körpern

\begin{bem}
  Zu jeder Primzahlpotenz $q = p^m \geq 2$ gibt es bis auf Isomorphie genau einen Körper $\GF_q = \F_q$ mit $q$ Elementen. Die Charakteristik dieses Körpers ist $p$. Ist $q$ keine Primzahlpotenz, so gibt es auch keinen Körper mit $q$ Elementen.
\end{bem}

\begin{konstr}
  Sei $q = p^m$, $p$ prim. Dann gibt es ein irreduzibles Polynom $g(x)$ in $\Z_p$ mit $\deg(g) = m$.
  Dann ist $\F_q \coloneqq \Z_p[x]/(g(x))$.
\end{konstr}

% §4.2. Das Minimalgewicht eines linearen Codes

% $q \geq 2$ sei eine Primzahlpotenz

\begin{defn}
  Ein \emph{$\F_q$-linearer Code} der Länge $n$ ist ein $\F_q$-Teilraum $\F_q^n$.
\end{defn}

\begin{nota}
  Sei $C$ ein $\R_q$-linearer Code.
  Sei $k \coloneqq \dim(C)$.
  Dann ist $\abs{C} = q^k$, also $C$ ein $(n, q^k)$-Code.
  Man sagt, $C$ ist ein $[n, k]$-Code. \\
  Ist $d$ der Minimalabstand von $C$, so: $C$ ist ein $[n,k,d]$-Code.
\end{nota}

\begin{defn}
  Sei $C$ ein $\F_q$-linearer Code mit $\dim(C) \geq 1$.
  Das \emph{Minimalgewicht} von $C$ ist $\min \Set{\wt(c)}{c \in C, c \neq 0}$.
\end{defn}

% 4.4
\begin{lem}
  Sei $C$ ein $\F_q$-linearer Code mit $\dim(C) \geq 1$.
  Dann:
  \[ \text{Minimalgewicht von $C$ = Minimalabstand von $C$.} \]
\end{lem}

\begin{bsp}
  Folgender Code ist ein bin. $(6, 8, 3)$-Code bzw. $[6, 3, 3]$-Code:
  \[
    \arraycolsep=1pt
    \left\{ \begin{array}{rl}
      000000,
      100101,
      & 010110,
      001111, \\
      110011,
      101010,
      & 011001,
      111100
    \end{array} \right\} \!=\! \spann \{ 100101, 010110, 001111 \}
  \]
\end{bsp}

% §4.3 Hauptproblemstellung für lineare Codes

% Gegeben: $\F_q$, Länge $n$, Minimalabstand $d$
% Gewicht: $A_q^{\lin}(n, d) \leq $

\begin{prob}
  Gegeben sei $\F_q$, die Länge $n$ und der Minimalabstand $d$. \\
  Gesucht ist $A_q^\lin(n, d)$, die bestmögliche Anzahl Wörter eines Codes mit diesen Parametern.
\end{prob}

\begin{bem}
  Klar ist $A_q^\lin(n, d) \leq A_q(n, d)$.
\end{bem}

% 4.6
\begin{lem}
  \begin{itemize}
    \item $A_q^\lin(n, 1) = q^n = A_q(n, 1)$
    \item $A_q^\lin(n, n) = q = A_q(n, n)$
    \item $d \leq d' \implies A_q^\lin(n, d) \geq A_q^\lin(n, d')$
    \item Für $n \geq 2$, $d \geq 2$ ist $A_q^\lin(n, d) \leq A_q^\lin(n-1, d-1)$.
  \end{itemize}
\end{lem}

\begin{bem}
  Da die Parity-Check-Erweiterung durch eine lineare Abbildung geschieht, gilt:
\end{bem}

\begin{satz}
  $A_1^\lin(n, 2) = q^{n-1} = A_q(n,2)$
\end{satz}

\begin{satz}
  Falls $d$ ungerade, so ist $A_2^\lin(n, d) = A_2^\lin(n+1, d+1)$
\end{satz}

% Nordstrom-Robinson-Code:
% Ein (16, 256, 6)-Code über $\F_2$

% Vorlesung vom 27.10.2015

% §4.4 Die Generatormatrix

\begin{defn}
  Sei $C$ ein $[n,k]$-Code über $\F_q$, \dh{} es gibt eine injektive Codierabbildung $E : \F_q^k \to \F_q^n$ mit $\im(E) = C$.
  Dann heißt für jede Basis $g^1, \ldots, g^k \in C$ von $C$ die Matrix
  \[
    G \coloneqq \begin{psmallmatrix}
      g^1 \\ \vdots \\ g^k
    \end{psmallmatrix} \in \F_q^{k \times n} \qquad
    \text{eine \emph{Generatormatrix} von $C$.}
  \]
\end{defn}

\begin{bem}
  Dann ist $E(u) = uG = \sum_{j=1}^k u_j g^j \in C$
\end{bem}

% Ausgelassen: Bspe Parity-Check-Erweiterung und 5-Wiederholungscode

\begin{defn}
  Zwei $[n,k]$-Codes $C, C' \subseteq \F_q^n$ heißen \emph{linear äquivalent}, falls es~$\gamma \in S_n$ und $\lambda_1, \ldots, \lambda_n \in \F_q^{\times}$ gibt, sodass die monomiale Transf. \[ \alpha : \F_q^n \to \F_q^n, \enspace (x_1, \ldots, x_n) \mapsto (\lambda_1 x_{\gamma(1)}, \ldots, \lambda_n x_{\gamma(n)}) \]
  den Code $C$ in $C'$ überführt.
\end{defn}

\iffalse
\begin{bspe}
  binäre $[5, 2, 3]$-Codes
  
  $C_1$ hat Generatormatrix $G_1 = \begin{psmallmatrix}
    11100 \\
    00111
  \end{psmallmatrix}$,
  $C_1 = \{ 00000, 111100, 00111, 11011 \}$
  
  $C_2$ hat Generatormatrix $G_2 = \begin{psmallmatrix}
    011001 \\
    10110
  \end{psmallmatrix}$
  $C_2 = \{ 00000, 01101, 10110, 11011 \}$
\end{bspe}
\fi

\begin{defn}
  Ein $[n,k]$-Code heißt \emph{systematisch}, falls die ersten $k$ Spalten seiner Generatormatrix die Standardbasisvektoren sind.
\end{defn}

% §4.5 Gewichtsminimale Repäsentanten und Standard-Array-Decodierung

\begin{nota}
  Sei $C \subset \F_q^n$ ein UVR. Für $x, y \in \F_q^n$ schreiben wir
  \[ x \equiv y \pmod{C} \coloniff x-y \in C. \]
  Die zu $x \in V$ gehörende Kongruenzklasse modulo $C$ ist $x + C$.
\end{nota}

\begin{defn}
  Ein Repräsentantensystem $\mathcal{R}$ dieser Klassen heißt \emph{gewichtsminimal}, falls $\wt(r) = \min_{c \in C} \wt(r+c)$ für alle $r \in \mathcal{R}$.
\end{defn}

\begin{satz}
  Sei $C$ ein $[n, k]$-Code über $\F_q$, $\mathcal{R}$ ein gewichtsmin. Repräsen- tantensystem mod $C$.
  Zu $y \in \F_q^n$ sei $\mathcal{R}(y) \in \R$ mit $\mathcal{R}(y) + C = y + C$.
  Dann ist $D : \F_q^n \to C, \enspace y \mapsto y - \mathcal{R}(y)$ eine Decodierabbildung.
\end{satz}

% Ausgelassen: Beispiel

% TODO: Standard-Array-Decodierung beschreiben

% §4.6 Dualer Code: Kontrollmatrix und Syndromdecodierung

\begin{bem}
  Sei $\F$ ein Körper, $n \in \N^*$.
  Das Standard-Skalarprodukt
  \[
    \scp{\blank}{\blank} : \F^n \times \F^n \to \F,
    \enspace (x, y) \mapsto \sum_{i=1}^n x_i y_i
  \]
  ist eine nicht-ausgeartete, symmetrische Bilinearform.
\end{bem}

% Ausgelassen: Definition des Orthogonalraums

\begin{acht}
  Es ist $\dim(U^\perp) = n - k$, im Allgemeinen gilt aber $U \cap U^\perp \neq 0$, \zB{} ist $11011 \in \F_2^5$ senkrecht zu sich selbst.
\end{acht}

\begin{defn}
  Sei $C$ ein $[n,k]$-Code über $\F_q$.
  Dann heißt $C^\perp$ der zu $C$ gehörende \emph{duale Code}.
\end{defn}

\begin{defn}
  Die Generatormatrix $H$ von $C^\perp$ heißt \emph{Kontrollmatrix} zu $C$.
\end{defn}

\begin{lem}
  $x \in C \iff H x^T = 0$
\end{lem}

\begin{alg}
  Sei $C$ ein $[n,k]$-Code, $H \in \F_q^{n-k \times n}$ die Kontrollmatrix.
  Dann ist
  \[ \psi_H : \F_q^n \to \F_q^{n-k}, \enspace x \mapsto H x^T \]
  eine surjektive lineare Abbildung mit $\ker(\psi_H) = C$.
  \begin{itemize}
    \item Sei $c \in C$ gesendet, $y \in \F_q^n$ empfangen, etwa $y = c + e$.
    Wir als Empfänger kennen jedoch $c$ und $e$ nicht, nur $y$.
    Trotzdem können wir das \emph{Syndrom} $s \coloneqq \phi_H(y) = H c^T + H e^T = H e^T \in \F_q^{n-k}$ berechnen.
    \item Wahrscheinlich ist $e$ ein gewichtsminimaler Repräsentant von $y$.
    Sei also $\mathcal{R}$ ein minimales Repräsentantensystem. \\
    Dann ist $\psi \coloneqq \psi_H|_{\mathcal{R}} : \mathcal{R} \to \F_q^{n-k}$ bijektiv. \\
    Dann definiert $D(y) \coloneqq y - \psi^{-1}(s)$ eine Decodierabbildung.
  \end{itemize}
\end{alg}

% Vorlesung vom 29.10.2015

\begin{satz}
  Sei~$C$ ein linearer $[n, k, d]$-Code über $\F_q$, $H$~eine Kontroll- matrix zu~$C$.
  Dann gilt:
  \begin{align*}
    d &= 1 + \max \Set{a \in \N^*}{\text{je $a$ Spalten von $H$ sind lineare unabhängig}} \\
    &= \min \Set{m \in \N^*}{\text{es gibt $m$ linear abhängige Spalten in $H$}}
  \end{align*}
\end{satz}

\begin{defn}
  Sei~$C$ ein linearer Code der Länge~$n$ über $\F_q$. \\
  Die \emph{Gewichtsverteilung von~$C$} ist
  $A = A_C \in \N^{\{ 0, 1, \ldots, n \}}$ mit
  \[
    A(i) \coloneqq \Set{w \in C}{\wt(w) = i}, \quad
    0 \leq i \leq n.
  \]
\end{defn}

\begin{bem}
  Es gilt $A_0 = 1$ und $A_1 = A_2 = \ldots = A_{d-1} = 0$, falls~$d$ das Minimalgewicht von $C$ ist.
\end{bem}

\begin{defn}
  $A_C(Z) \coloneqq \sum_{i=0}^k A_i Z^k \in \C[Z]$ heißt \emph{Gewichtszählpolynom},
  \[ A_C^\homogen(X, Y) \coloneqq \sum_{i=0}^n A_i X^{n-i} \cdot Y^i \in \C[X, Y] \]
  heißt \emph{homogenes Gewichtszählpolynom}.
\end{defn}

\begin{bem}
  \inlineitem{$A_C(Z) = A_C^\homogen(1, Z)$} \quad
  \inlineitem{$A_C^\homogen(X, Y) = X^n \cdot A_C(\tfrac{Y}{X})$}
  \begin{itemize}
    \item Aus $A_C(X, Y)$ erhält man durch die sogenannte Mac-Williams-Transformation $A_{C^\perp}(X, Y)$
  \end{itemize}
\end{bem}

% §5. Hamming-Codes

% §5.1. Die Parameter eines 1-fehlerkorrigierenden perfekten linearen Codes

\begin{lem}
  Sei $C$ ein perfekter $(n, M, d)$-Code. %über $Q$ mit $q = \abs{Q}$.
  Dann ist $d$ ungerade.
\end{lem}

\begin{bem}
  Wir betrachten nun perfekte Codes $C$ mit $t=1$, also $d=3$.
  Es gilt dann $\abs{C} = \nicefrac{q^n}{1 + n(q-1)}$, es ist also $1+n(q-1)$ ein Teiler von~$q^n$.
  Beispielsweise ist für~$q \geq 2$ und~$n = q+1$ die Zahl $1 + n(q-1) = q^2$ ein Teiler von~$q^n$.
  Diese Teilbarkeit ist eine notwendige, aber nicht hinreichende Bedingung für die Existenz eines perfekten $(n, M, 3)$-Codes über $Q$ mit $q = \abs{Q}$.
  %Zum Bsp gibt es keinen perfekten Code bei $q=6$.
\end{bem}

\begin{lem}
  Seien $p, u, v \in \N$, $p \geq 2$. Dann gilt $u \divides v \iff p^u - 1 \divides p^v - 1$.
\end{lem}

\begin{prop}
  Sei $C$ perfekt mit $t=1$ über $Q$, wobei $\abs{Q} = q$ eine Primzahlpotenz ist.
  Dann ist $\abs{C}$ eine $q$-Potenz.
\end{prop}

\begin{bem}
  Sei nun $q \geq 2$ eine Primzahlpotenz, $C$ ein $q$-närer perfekter $(n, M, 3)$-Code.
  Dann ist
  \[ q^k = \abs{C} = M = \nicefrac{q^n}{1 + n(q-1)} \iff n = \nicefrac{(q^{n-k} - 1)}{q - 1} \]
  Wie viele Lösungspaare $(n, k)$ gibt es bei festem $q$?
  Wir setzen $m \coloneqq n - k$.
  Dann ist $k(m) \coloneqq n - m$ und $n(m) \coloneqq \tfrac{q^m - 1}{q - 1}$.
  Die Lösungspaare hängen damit nur noch vom Parameter $m$ ab.
\end{bem}

\end{document}